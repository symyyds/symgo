<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python函数和类</title>
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/dropdown.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Python学习页面特定样式 */
        :root {
            --primary-color: #3776ab;
            --secondary-color: #ffd343;
            --bg-color: #f8f9fa;
            --code-bg: #f1f1f1;
            --output-bg: #e9ecef;
            --text-color: #333;
            --border-radius: 6px;
        }
        
        .section {
            margin-bottom: 3rem;
            background-color: white;
            padding: 2rem;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .code-block {
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .code-header {
            background-color: #4a4a4a;
            color: white;
            padding: 0.5rem 1rem;
            font-family: monospace;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .code {
            background-color: var(--code-bg);
            padding: 1rem;
            font-family: monospace;
            overflow-x: auto;
            white-space: pre;
        }
        
        .output {
            background-color: var(--output-bg);
            padding: 1rem;
            font-family: monospace;
            border-top: 1px solid #ddd;
        }
        
        .keyword { color: #0000ff; }
        .string { color: #a31515; }
        .comment { color: #008000; }
        .number { color: #098658; }
        .function { color: #795e26; }
        
        .note {
            background-color: #e7f3fe;
            border-left: 4px solid #2196F3;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--border-radius);
        }
        
        .tip {
            background-color: #ddffdd;
            border-left: 4px solid #4CAF50;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--border-radius);
        }
        
        .python-nav {
            margin-bottom: 2rem;
            background-color: #fff;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .python-nav ul {
            display: flex;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .python-nav ul li {
            flex: 1;
            text-align: center;
        }
        
        .python-nav ul li a {
            display: block;
            padding: 1rem;
            color: var(--text-color);
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        .python-nav ul li a:hover,
        .python-nav ul li a.active {
            background-color: var(--primary-color);
            color: white;
        }

        /* 嵌套下拉菜单样式 */
        .nested-dropdown {
            position: relative;
            display: block;
        }

        .nested-dropdown-content {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background-color: white;
            min-width: 160px;
            box-shadow: var(--shadow);
            z-index: 2;
            border-radius: var(--border-radius);
        }

        .nested-dropdown:hover .nested-dropdown-content {
            display: block;
        }

        .nested-dropdown-content a {
            color: var(--text-color);
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            transition: var(--transition);
        }

        .nested-dropdown-content a:hover {
            background-color: var(--bg-color);
            color: var(--primary-color);
        }

        .nested-dropdown-content a.active {
            background-color: var(--primary-color);
            color: white;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="profile">
                <img src="../images/sym_photo.jpg" alt="个人照片" class="profile-img">
                <div class="profile-info">
                    <h1>孙远鸣</h1>
                    <p class="title">独善其身</p>
                    <p class="keywords">CS | SE</p>
                </div>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">首页</a></li>
                    <li><a href="../blog.html">博客</a></li>
                    <li><a href="../ai.html">AI聊天</a></li>
                    <li class="dropdown">
                        <a href="#" class="active">工具箱</a>
                        <div class="dropdown-content">
                            <a href="code_runner.html">代码高亮</a>
                            <div class="nested-dropdown">
                                <a href="python_study.html" class="active">Python学习</a>
                                <div class="nested-dropdown-content">
                                    <a href="python_study.html">基础语法</a>
                                    <a href="python_study1.html">数据类型</a>
                                    <a href="python_study2.html">控制流程</a>
                                    <a href="python_study3.html" class="active">函数和类</a>
                                </div>
                            </div>
                        </div>
                    </li>
                    <li><a href="../leave_message.html">留言板</a></li>
                </ul>
            </nav>
        </div>
    </header>
    
    <main>
        <section class="page-header">
            <div class="container">
                <h1>Python函数和类</h1>
                <p>学习Python的函数定义、类和面向对象编程</p>
            </div>
        </section>
        
        <div class="container">
            <nav class="python-nav">
                <ul>
                    <li><a href="python_study.html">基础语法</a></li>
                    <li><a href="python_study1.html">数据类型</a></li>
                    <li><a href="python_study2.html">控制流程</a></li>
                    <li><a href="python_study3.html" class="active">函数和类</a></li>
                </ul>
            </nav>
            
            <!-- 原有内容保持不变 -->
            <div class="nav">
                <div class="nav-title">目录</div>
                <ul>
                    <li><a href="#intro">面向过程编程</a></li>
                    <li><a href="#oop">面向对象编程</a></li>
                    <li><a href="#class-object">类和对象</a></li>
                    <li><a href="#encapsulation">封装</a></li>
                    <li><a href="#inheritance">继承</a></li>
                    <li><a href="#polymorphism">多态</a></li>
                    <li><a href="#magic-methods">魔法方法</a></li>
                </ul>
            </div>

            <div class="container">
                <!-- 面向过程编程 -->
                <div id="intro" class="section">
                    <h2>面向过程编程</h2>
                    <p>面向过程就是一种以过程为中心的编程思想。把要完成的事情拆分为几个步骤，然后按照顺序来执行，典型代表：C语言。</p>
                </div>

                <!-- 面向对象编程 -->
                <div id="oop" class="section">
                    <h2>面向对象编程</h2>
                    <p>面向对象则会把事物抽象成对象，然后给每个对象赋一些属性和方法，让每个对象都去执行自己的方法，典型代表：Java、Python。</p>

                    <h3>举个洗衣服的例子</h3>
                    <div class="code-container">
                        <div class="code">**面向过程：**
- 放衣服
- 放洗衣粉
- 放水
- 清洗
- 甩干

**面向对象：**
1. 创建出两个对象："人"和"洗衣机"
2. 在"人"和"洗衣机"中加入属性和方法
3. 然后只需执行这两个对象即可</div>
                    </div>
                </div>

                <!-- 类和对象 -->
                <div id="class-object" class="section">
                    <h2>类和对象</h2>
                    
                    <h3>类的定义</h3>
                    <p>类是具有相同属性和功能的一类事物。</p>

                    <h3>对象的定义</h3>
                    <p>对象是类的具体体现，是面向对象编程的核心。</p>

                    <ul>
                        <li><strong>动物(类)</strong> → 猫、狗、熊(对象)</li>
                        <li><strong>人类(类)</strong> → 张三、李四、王五(对象)</li>
                    </ul>

                    <h3>类和对象的语法结构</h3>
                    <div class="code-container">
                        <div class="code"># 自定义类的语法结构
class 类名():
    pass

# 创建对象的语法格式
对象名 = 类名()</div>
                </div>

                <h3>基本示例</h3>
                <div class="code-container">
                    <div class="code">a = 10 # <class 'int'> 整型类别
b = 9.9 # <class 'float'>
c = "hello world" #<class 'str'>
print(type(a))
print(type(b))
print(type(c))

class Person(): # 定义一个Person类
    pass # 用pass占位 避免语法错误

class Pig(): # 定义一个Pig类
    pass

# 创建对象 对象名=类名()
people = Person() # people就是Person类型的对象
zhu = Pig() # zhu就是Pig类型的对象
print(type(people)) # <class '__main__.Person'>
print(type(zhu)) # <class '__main__.Pig'></div>
                    <div class="code-result">&lt;class 'int'&gt;
&lt;class 'float'&gt;
&lt;class 'str'&gt;
&lt;class '__main__.Person'&gt;
&lt;class '__main__.Pig'&gt;</div>
                </div>

                <h3>类中的属性和方法</h3>
                <p><strong>属性</strong>：对象的特征描述（本质为类中定义的变量）</p>
                <p><strong>方法</strong>：对象具有的行为（本质为函数）</p>
                <ul>
                    <li><strong>类属性</strong>：定义在类中、方法之外的，属于类，可以通过 "类名.属性名" 来访问</li>
                    <li><strong>实例属性</strong>：从属于实例对象的属性，一般在 __init__() 方法中通过如下代码定义：self.实例属性名 = 初始值</li>
                    <li><strong>实例方法</strong>：定义在类中的函数，且自带参数 self</li>
                    <li><strong>类方法</strong>：使用装饰器 @classmethod 来声明，第一个参数通常被命名为 cls，它指向类而不是实例</li>
                    <li><strong>静态方法</strong>：使用装饰器 @staticmethod 来声明，是类中的独立函数</li>
                </ul>

                <div class="code-container">
                    <div class="code">class Person():
    height = 185  # 类属性
    weight = 140  # 类属性
    def __init__(self,name,age): # 初始方法，name、age是方法的参数，是局部变量
        self.name = name # 左侧self.name为实例属性，右侧为局部变量name
        self.age = age
    def sing(self):  # 实例方法
        print("我唱歌很厉害~")
    def jump(self): # 实例方法
        print("我一脚能跳2米高~")
    def show(self): # 实例方法
        print(f"我叫{self.name}，今年有{self.age}岁啦") # 必须使用实例属性
    @classmethod
    def class_method(cls):  # 类方法
        print(f"我的身高是{cls.height}")
    @staticmethod
    def add(a,b):  # 静态方法
        result = a+b
        return result

# 创建对象
person = Person("01",18)
print(Person.height) # 类属性
print(person.name) # 实例属性
person.jump() # 实例方法
Person.class_method() # 类方法
print(Person.add(1,2)) # 静态方法</div>
                    <div class="code-result">185
01
我一脚能跳2米高~
我的身高是185
3</div>
                </div>

                <h3>创建多个对象示例</h3>
                <div class="code-container">
                    <div class="code">class Person():
    height = 185  # 类属性
    weight = 140  # 类属性
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def sing(self):
        print("我唱歌很厉害~")
    def jump(self):
        print("我一脚能跳2米高~")
    def show(self):
        print(f"我叫{self.name}，今年有{self.age}岁啦")

# 根据类可以创建多个对象
per1 = Person("张三","19")
per2 = Person("李四","20")
per3 = Person("王五","21")
print("***"*10)
print(per1.name)
print(per2.name)
print(per3.name)
print("***"*10)
# 循环打印
lst = [per1,per2,per3]
for item in lst:
    print(item.age)</div>
                    <div class="code-result">******************************
张三
李四
王五
******************************
19
20
21</div>
                </div>

                <h3>Home类示例</h3>
                <div class="code-container">
                    <div class="code">class Home():
    def __init__(self,size,height,value):
        self.size = size
        self.height = height
        self.value = value
    def tv(self):
        print("打开电视，看电视~！")

home1 = Home(100,3,200)
print(home1.size)
home1.tv()</div>
                    <div class="code-result">100
打开电视，看电视~！</div>
                </div>

                <h3>动态绑定属性和方法</h3>
                <div class="code-container">
                    <div class="code">class Home():
    def __init__(self,size,height,value):
        self.size = size
        self.height = height
        self.value = value
    def tv(self):
        print("打开电视，看电视~！")

home1 = Home(100,3,200)
home2 = Home(110,3,240)
home1.age = 100 # 给home1动态绑定实例属性
print(home1.age)
# print(home2.age)  # 这行会报错，因为home2没有age属性

def home_type():
    print("这是一个豪宅")
home1.fun = home_type # 函数赋值，fun为home1对象的方法
home1.fun()</div>
                    <div class="code-result">100
这是一个豪宅</div>
                </div>
            </div>

            <!-- 封装 -->
            <div id="encapsulation" class="section">
                <h2>封装</h2>
                <p>封装是面向对象编程中最重要的特性。封装就是将数据和功能整合在一起。针对封装到对象或者类中的属性，可以严格控制在类外部对它们的访问，即隐藏属性和开放接口。</p>

                <h3>封装的好处</h3>
                <ul>
                    <li>提高程序的安全性。</li>
                    <li>防止外部代码直接访问对象内部的状态，外部只能通过定义好的接口来操作对象。</li>
                </ul>

                <h3>实现方式</h3>
                <p>封装通过定义<strong>私有属性</strong>和<strong>公共方法</strong>来实现。</p>

                <h3>封装中的主要概念</h3>
                <ul>
                    <li><strong>类</strong>是抽象出来的概念，在现实世界中是不存在的。</li>
                    <li><strong>对象</strong>是具体的概念，在现实世界中是真实存在的。</li>
                </ul>

                <h3>为什么需要封装</h3>
                <ol>
                    <li><strong>隐藏实现细节</strong>：封装可以将类的内部细节隐藏起来，使得外部无法直接访问对象的属性或方法，从而保护数据不受意外修改。</li>
                    <li><strong>简化接口</strong>：通过封装，我们可以提供简洁清晰的外部接口，使得使用者无需了解类的内部实现细节，只需通过接口来操作对象。</li>
                </ol>

                <h3>封装的实现方式</h3>
                <p>在面向对象编程中，封装可以通过以下方式实现：</p>
                <ul>
                    <li><strong>私有属性和方法</strong>：使用语言提供的特殊语法（如在 Python 中使用双下划线 `__` 开头的属性或方法）来限制对属性和方法的访问，使其只能在类的内部被访问。</li>
                    <li><strong>公有接口方法</strong>：提供公有的方法来访问和修改私有属性，从而实现对属性的控制和保护。</li>
                </ul>

                <h3>封装的优点</h3>
                <ul>
                    <li><strong>安全性</strong>：封装可以保护类的内部数据不被外部直接访问，提高数据安全性。</li>
                    <li><strong>灵活性</strong>：封装使得类的内部实现细节可以随时修改而不影响外部调用者。</li>
                    <li><strong>简化接口</strong>：封装可以提供简单清晰的外部接口，减少调用者需要了解的类的细节，降低了使用难度。</li>
                </ul>

                <h3>访问限制</h3>
                <ul>
                    <li><strong>单下划线开头</strong>：属性或方法以单下划线开头，表示它们是受保护的，在类的内部和子类中可以被访问，但是不建议直接访问。这种命名约定被称为"受保护的"（protected）。</li>
                    <li><strong>双下划线开头</strong>：属性或方法以双下划线开头，表示它们是私有的，只能在类的内部访问，外部无法直接访问。这种命名约定被称为"私有的"（private）。</li>
                    <li><strong>双下划线开头和结尾</strong>：魔法方法，如常见的 ： `__init__`、`__del__` 等。这些方法在类或对象进行特定的操作时会自动被调用，我们可以使用或重写这些魔法方法，给自定义的类添加各种特殊的功能来满足自己的需求。</li>
                </ul>

                <div class="code-container">
                    <div class="code">class Person():
    def __init__(self,name,age,height):
        self._name = name # self._name 受保护的，只能本类和子类访问
        self.__age = age # self.__age 私有的 只能在类的内部访问
        self.height = height # 实例属性，类的内部，外部，子类都可以访问

person5 = Person("01",18,185)
print(person5._name) # 调用受保护的实例
# person5.__age  # 调用私有的实例属性 会报错
print(person5._Person__age)  # 输出: 18 不推荐
dir(person5) # 查看对象的所有属性和方法</div>
                </div>
            </div>

            <!-- 继承 -->
            <div id="inheritance" class="section">
                <h2>继承</h2>

                <h3>现实生活中的继承含义</h3>
                <p>"子承父业"是继承在现实生活中的含义，表示子代从父代继承事业或特长。</p>

                <h3>在Python中的继承</h3>
                <p>继承是一种类与类之间的关系，描述了一个类从另一个类获取成员（属性和方法）的信息。实现继承的类称为<strong>子类</strong>，被继承的类称为<strong>父类</strong>。</p>

                <h3>继承的作用</h3>
                <p>继承可以使得子类具有父类的各种属性和方法，这样就不需要在子类中重复编写相同的代码，能够提高代码的复用性。</p>

                <h3>继承的特性</h3>
                <ul>
                    <li><strong>一个子类可以继承多个父类</strong>：Python支持多重继承，即一个类可以继承多个类的属性和方法。</li>
                    <li><strong>一个父类可以有多个子类</strong>：一个父类可以被多个子类继承，形成类的层次结构。</li>
                    <li><strong>默认继承object类</strong>：如果一个类没有显式继承任何类，它默认继承自Python的根类object。</li>
                </ul>

                <h3>继承的格式</h3>
                <div class="code-container">
                    <div class="code">class 类名(父类名):
    pass</div>
                </div>

                <h3>特点</h3>
                <ol>
                    <li><strong>代码重用</strong>：继承允许子类重用父类的代码，避免了重复编写相似的代码。</li>
                    <li><strong>扩展性</strong>：子类可以在继承父类的基础上添加新的属性和方法，从而增强了类的功能。</li>
                    <li><strong>覆盖方法</strong>：子类可以重写父类的方法，以实现特定的行为。</li>
                </ol>

                <h3>类型</h3>
                <p>根据继承的方式，可以将继承分为以下几种类型：</p>
                <ul>
                    <li><strong>单继承</strong>：一个子类只继承一个父类。</li>
                    <li><strong>多继承</strong>：一个子类继承多个父类。</li>
                    <li><strong>多层继承</strong>：一个子类继承自另一个子类，而后者又继承自一个父类。</li>
                    <li><strong>混合继承</strong>：结合了单继承和多继承的特性，使得子类同时具有多个父类的特征。</li>
                </ul>

                <h3>语法</h3>
                <p>在Python中，可以使用以下语法实现继承：</p>
                <div class="code-container">
                    <div class="code">class ParentClass:
    # 父类的属性和方法

class ChildClass(ParentClass):
    # 子类的属性和方法</div>
                </div>

                <div class="code-container">
                    <div class="code">class Person(): # 定义一个Person类 默认继承object类
    def __init__(self,name,age):
        self.name = name # 定义实例属性 name，用于存储人名
        self.age = age
    def fun(self):
        print(f"我叫{self.name}，今年{self.age}岁啦~~")

class bask_person(Person):
    def __init__(self, name, age):
        super().__init__(name, age) # 调用父类 Person 的初始化方法，传入姓名和年龄
        print(f"我叫{self.name}，今年{self.age}岁了，我打篮球很厉害")

class sing_person(Person):
    def __init__(self, name, age):
        super().__init__(name, age)
        print(f"我叫{self.name}，今年{self.age}岁了，我唱歌很厉害")

people1 = bask_person("张三",25)  # 创建 bask_person 类的实例，姓名为 "张三"，年龄为 25
people2 = sing_person("李四",28)
people1.fun()  # 调用父类的 fun 方法打印个人信息</div>
                </div>

                <h3>多继承示例</h3>
                <div class="code-container">
                    <div class="code">class A():
    def printA(self): # 无实例属性。可以不写初始化方法
        print("AAAAAAAA")

class B():
    def printB(self):
        print("BBBBBBBB")

class C(A,B):
    def printC(self):
        print("CCCCCCCCC")

c1 = C() # 创建 C 类的实例
c1.printB() # 调用 A 类的方法</div>
                </div>

                <h3>重写父类方法</h3>
                <div class="code-container">
                    <div class="code">class Dog():
    def say(self):
        print("aoaoao")

class X_dog(Dog): 
    pass
    def say(self):
        print("gogogo")

xiaobai = X_dog()
xiaobai.say()</div>
                </div>
            </div>

            <!-- 多态 -->
            <div id="polymorphism" class="section">
                <h2>多态</h2>

                <h3>多态的含义</h3>
                <p>多态指的是一类事物有多种形态。例如，动物类可以有猫、狗、羊等多个子类。多态表现为同一个方法或操作，在不同的对象上有不同的表现形式。</p>

                <h3>多态的概念</h3>
                <p>多态是一种使用对象的方式。具体而言，子类可以重写父类的方法，当调用相同的方法时，不同子类的对象会表现出不同的行为。</p>

                <h3>多态的好处</h3>
                <p><strong>代码简洁</strong>：多态使得父类的接口能够处理不同类型的对象，代码更加简洁且具有兼容性。</p>
                <p><strong>易于扩展</strong>：只需要新增子类并重写父类方法，外部代码可以无缝适应新增的子类，提升代码的可扩展性和维护性。</p>

                <div class="code-container">
                    <div class="code">class Animal: # 动物类
    def eat(self):
        pass

class Dog(Animal): #动物的形态之一:狗
    def eat(self):
        print('狗喜欢吃骨头')

class Cat(Animal): #动物的形态之二:猫
    def eat(self):
        print('猫喜欢吃鱼')

class Pig(Animal): #动物的形态之三:猪
    def eat(self):
        print('猪喜欢吃糠')

#实例化三个对象
dog=Dog()
cat=Cat()
pig=Pig()

def Eat(animal): # 定义一个Eat函数
    animal.eat()

Eat(cat) # 调用 Eat 函数并传入不同的动物实例
Eat(dog)
Eat(pig)</div>
                </div>
            </div>

            <!-- 魔法方法 -->
            <div id="magic-methods" class="section">
                <h2>魔法方法</h2>

                <h3>定义</h3>
                <p><strong>魔法方法</strong>（也称为<strong>特殊方法</strong>或<strong>双下划线方法</strong>）是Python中一些具有特殊功能的方法，它们以双下划线`__`开头和结尾。</p>

                <div class="code-container">
                    <div class="code">class List_1:
    def __init__(self, lst):
        """
        初始化方法
        参数:
            lst (list): 要包装的列表。
        """
        self.lst = lst

    def __getitem__(self, index):
        """
        获取指定索引位置的元素。
        参数:
            index (int): 要获取元素的索引。
        返回:
            该索引位置的元素。
        """
        return self.lst[index]

    def __delitem__(self, index):
        """
        删除指定索引位置的元素。
        参数:
            index (int): 要删除元素的索引。
        """
        del self.lst[index]

    def __len__(self):
        """
        返回列表的长度。
        返回:
            列表的长度。
        """
        return len(self.lst)

    def append(self, item):
        """
        向列表末尾添加一个新元素。
        参数:
            item: 要添加的新元素。
        """
        self.lst.append(item)

# 创建一个列表
my_list = [1, 2, 3, 4, 5]

# 实例化 List_1 对象，传入列表作为参数
wrapper = List_1(my_list)

# 使用魔法方法获取列表中的第三个元素
print(wrapper.__getitem__(2))  

# 使用魔法方法获取列表的长度
print(wrapper.__len__())  

# 使用魔法方法向列表末尾添加一个新元素
wrapper.append(6)

# 查看列表的内容
print(wrapper.lst)  

# 使用魔法方法删除列表中的第一个元素
wrapper.__delitem__(0)
print(wrapper.lst) 

# 使用魔法方法获取列表的长度
print(wrapper.__len__())</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });

        // 代码高亮
        document.querySelectorAll('.code').forEach(block => {
            const code = block.innerHTML;
            const highlighted = code
                .replace(/\b(class|def|self|super|pass|return|print|for|in|if|else|elif)\b/g, '<span class="keyword">$1</span>')
                .replace(/(['"])(.*?)\1/g, '<span class="string">$&</span>')
                .replace(/\b(\d+(\.\d+)?)\b/g, '<span class="number">$1</span>')
                .replace(/(#.*$)/gm, '<span class="comment">$1</span>')
                .replace(/\b(@classmethod|@staticmethod)\b/g, '<span class="keyword">$1</span>')
                .replace(/\b(__init__|__len__|__getitem__|__str__|__del__|__delitem__|__setitem__)\b/g, '<span class="function">$1</span>');
            block.innerHTML = highlighted;
        });
    </script>
</body>
</html>
